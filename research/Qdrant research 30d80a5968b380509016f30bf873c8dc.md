# Qdrant research

## 1. Introduction

### 1.1 Bài toán cần giải quyết

Trong các hệ thống tìm kiếm và gợi ý hiện đại, dữ liệu thường tồn tại dưới dạng **phi cấu trúc** như văn bản, mô tả sản phẩm, tài liệu, hoặc hội thoại người dùng. Các hệ quản trị cơ sở dữ liệu truyền thống (ví dụ: PostgreSQL, MySQL) chủ yếu hỗ trợ truy vấn dựa trên **so khớp từ khóa hoặc điều kiện chính xác**, do đó gặp nhiều hạn chế khi phải xử lý các truy vấn mang tính **ngữ nghĩa**.

Ví dụ, các truy vấn như *“sản phẩm giống iPhone”*, *“bài viết nói về du lịch biển”* hay *“tài liệu liên quan đến bảo mật dữ liệu”* không thể được xử lý hiệu quả chỉ bằng các toán tử so khớp chuỗi thông thường. Người dùng có thể sử dụng những từ khác nhau để mô tả cùng một ý nghĩa, dẫn đến việc kết quả tìm kiếm thiếu đầy đủ hoặc không chính xác.

### 1.2 Vì sao cần vector search

Vector search giải quyết bài toán trên bằng cách **biểu diễn dữ liệu theo ý nghĩa thay vì từ ngữ**. Nội dung (ví dụ: văn bản) được chuyển đổi thành **vector embedding** thông qua các mô hình học máy, trong đó mỗi vector đại diện cho ngữ nghĩa tổng quát của dữ liệu.

Nhờ cách biểu diễn này:

- Các dữ liệu có **ý nghĩa tương đồng** sẽ có vector nằm gần nhau trong không gian nhiều chiều
- Truy vấn không còn phụ thuộc vào việc trùng khớp từ khóa
- Hệ thống có khả năng hiểu **từ đồng nghĩa, diễn đạt khác nhau, và thậm chí đa ngôn ngữ**

Vector search vì vậy trở thành nền tảng cho các hệ thống:

- Semantic search
- Recommendation system
- Retrieval‑Augmented Generation (RAG) cho các mô hình ngôn ngữ lớn

### 1.3 Vai trò của Qdrant

Qdrant đóng vai trò là một **vector database chuyên dụng**, được thiết kế để lưu trữ, lập chỉ mục và truy vấn vector embedding ở quy mô lớn với độ trễ thấp và tính ổn định cao.

Khác với việc triển khai vector search ở tầng ứng dụng (ví dụ: lưu embedding trong PostgreSQL và xử lý logic tìm kiếm ở application layer), Qdrant đưa toàn bộ **vector search logic xuống tầng database**, cho phép:

- Tìm kiếm ngữ nghĩa hiệu quả
- Kết hợp lọc metadata trong cùng một truy vấn
- Dễ dàng mở rộng khi số lượng vector tăng lớn

## 2. Overview of Qdrant

### 2.1 Định nghĩa

Qdrant là một **vector similarity search engine và vector database**, cung cấp API để lưu trữ, tìm kiếm và quản lý các vector embedding kèm theo metadata (payload).

Trong Qdrant, mỗi bản ghi (được gọi là *point*) bao gồm:

- Một hoặc nhiều vector embedding (dense hoặc sparse)
- Một định danh duy nhất (ID)
- Payload chứa dữ liệu bổ sung dạng JSON

Vector được xem là **thành phần trung tâm**, trong khi payload đóng vai trò hỗ trợ cho việc lọc và hiển thị thông tin.

### 2.2 Use cases chính

Qdrant thường được sử dụng trong các kịch bản sau:

- **Semantic search**: tìm kiếm tài liệu hoặc nội dung dựa trên ý nghĩa
- **Recommendation systems**: gợi ý sản phẩm, nội dung hoặc tài liệu tương tự
- **RAG pipelines**: truy xuất ngữ cảnh liên quan để cung cấp cho mô hình ngôn ngữ lớn
- **Hybrid search systems**: kết hợp tìm kiếm theo từ khóa và theo ngữ nghĩa
- **Multi‑modal search**: tìm kiếm trên nhiều loại dữ liệu như văn bản, hình ảnh, hoặc âm thanh

Trong các hệ thống này, Qdrant thường hoạt động song song với cơ sở dữ liệu truyền thống, thay vì thay thế hoàn toàn chúng.

## 3. Retrieval Process

### 3.1 Embedding

Quy trình truy xuất trong Qdrant bắt đầu bằng việc chuyển đổi dữ liệu đầu vào (văn bản, hình ảnh, v.v.) thành **vector embedding** thông qua một mô hình học máy.

Embedding là các vector số nhiều chiều, trong đó:

- Các dữ liệu có nội dung tương tự sẽ có vector gần nhau
- Việc so sánh được thực hiện bằng các độ đo khoảng cách như cosine similarity hoặc dot product

### 3.2 Dense vs Sparse

Qdrant hỗ trợ hai loại vector chính:

- **Dense vectors**:
    - Được tạo bởi các mô hình ngôn ngữ hoặc thị giác hiện đại
    - Có số chiều tương đối thấp (hàng trăm đến vài nghìn)
    - Mạnh trong việc nắm bắt **ngữ nghĩa tổng quát**
- **Sparse vectors**:
    - Thường đại diện cho thông tin dựa trên từ khóa
    - Có số chiều rất lớn nhưng phần lớn giá trị bằng 0
    - Phù hợp cho các truy vấn yêu cầu độ chính xác từ vựng cao

Việc hỗ trợ cả hai loại vector cho phép Qdrant thực hiện **hybrid search** một cách hiệu quả.

### 3.3 Top‑K retrieval

Khi người dùng gửi một truy vấn:

1. Truy vấn được chuyển thành vector embedding
2. Qdrant tính toán độ tương đồng giữa vector truy vấn và các vector trong collection
3. Hệ thống trả về **Top‑K vector gần nhất**, trong đó K do người dùng xác định

Cách tiếp cận này cho phép cân bằng giữa:

- Độ chính xác của kết quả
- Độ trễ truy vấn
- Khả năng mở rộng hệ thống

### 3.4 Hybrid search

Hybrid search là sự kết hợp giữa:

- **Semantic search** (dense vector)
- **Keyword‑based search** (sparse vector)

Trong Qdrant, hai tín hiệu này có thể được xử lý trong **cùng một truy vấn**, thay vì phải thực hiện và hợp nhất kết quả ở tầng ứng dụng. Điều này giúp:

- Đơn giản hóa kiến trúc hệ thống
- Giảm độ phức tạp của logic fusion
- Cải thiện hiệu năng và tính ổn định khi mở rộng quy mô

## 4. System Architecture

### 4.1 Client–server

Qdrant được thiết kế theo mô hình **client–server**, trong đó Qdrant server chịu trách nhiệm lưu trữ, lập chỉ mục và truy vấn vector, còn client đóng vai trò gửi dữ liệu và truy vấn từ các ứng dụng bên ngoài.

Kiến trúc này cho phép:

- Tách biệt rõ ràng giữa **logic ứng dụng** và **logic tìm kiếm vector**
- Dễ dàng tích hợp Qdrant như một dịch vụ độc lập trong hệ thống microservices
- Hỗ trợ mở rộng theo chiều ngang khi khối lượng dữ liệu và truy vấn tăng

Qdrant server tập trung xử lý các tác vụ nặng như xây dựng chỉ mục vector, tìm kiếm độ tương đồng và lọc metadata, giúp giảm tải cho tầng ứng dụng.

### 4.2 API & SDK

Qdrant cung cấp các giao diện giao tiếp thông qua:

- **HTTP REST API**
- **gRPC API**

Ngoài ra, Qdrant hỗ trợ các SDK chính thức cho nhiều ngôn ngữ lập trình phổ biến như:

- Python
- JavaScript / TypeScript
- Go
- Java
- .NET

Nhờ đó, Qdrant có thể được tích hợp linh hoạt vào nhiều hệ thống khác nhau mà không phụ thuộc vào ngôn ngữ hay nền tảng triển khai

## 5. Data Model & Indexing

### 5.1 Collection / Point / Payload

Qdrant tổ chức dữ liệu theo các khái niệm chính sau:

- **Collection**:
    
    Là một tập hợp các point, tương tự như bảng trong cơ sở dữ liệu quan hệ. Mỗi collection được cấu hình với các loại vector và distance metric cụ thể.
    
- **Point**:
    
    Là đơn vị dữ liệu cơ bản trong Qdrant. Mỗi point bao gồm:
    
    - Một hoặc nhiều vector embedding
    - Một định danh duy nhất (ID)
    - Payload chứa metadata dạng JSON
- **Payload**:
    
    Là dữ liệu bổ sung gắn với mỗi vector, dùng cho:
    
    - Lọc kết quả tìm kiếm
    - Lưu thông tin mô tả (ví dụ: giá, danh mục, nhãn)

Trong mô hình này, **vector là thành phần trung tâm**, còn payload đóng vai trò hỗ trợ cho truy vấn và hiển thị kết quả.

### 5.2 HNSW

Qdrant sử dụng **Hierarchical Navigable Small World (HNSW)** làm cấu trúc lập chỉ mục chính cho vector search. HNSW là một cấu trúc đồ thị cho phép:

- Tìm kiếm các vector gần nhất với độ chính xác cao
- Thực hiện truy vấn trong thời gian dưới tuyến tính (sublinear time)
- Duy trì hiệu năng ổn định khi số lượng vector tăng lớn

Việc sử dụng HNSW giúp Qdrant tránh việc phải so sánh truy vấn với toàn bộ dữ liệu, thay vào đó chỉ duyệt qua một tập ứng viên tiềm năng.

### 5.3 Payload index

Payload index là cơ chế cho phép Qdrant lập chỉ mục trên các trường metadata trong payload. Điểm đặc biệt là payload index **được tích hợp trực tiếp vào đồ thị HNSW**, cho phép:

- Áp dụng điều kiện lọc ngay trong quá trình tìm kiếm vector
- Tránh các bước lọc trước hoặc lọc sau gây tốn chi phí

Nhờ đó, Qdrant có thể kết hợp **semantic search và metadata filtering trong một lần truy vấn duy nhất**.

## 6. Deployment Options

### 6.1 OSS vs Cloud

Qdrant hỗ trợ nhiều mô hình triển khai khác nhau:

- **Open Source (OSS)**:
    
    Người dùng tự triển khai và quản lý Qdrant trên hạ tầng của mình (on‑premises hoặc cloud).
    
- **Qdrant Cloud (Managed Service)**:
    
    Qdrant được vận hành và quản lý bởi đội ngũ Qdrant, cung cấp các tính năng quản lý, giám sát và mở rộng tự động.
    

### 6.2 Ưu / nhược điểm

**OSS**

- Ưu điểm:
    - Toàn quyền kiểm soát dữ liệu và hạ tầng
    - Phù hợp cho môi trường nghiên cứu hoặc yêu cầu bảo mật cao
- Nhược điểm:
    - Phải tự quản lý scaling, backup và monitoring

**Cloud**

- Ưu điểm:
    - Không cần quản lý hạ tầng
    - Dễ dàng mở rộng và vận hành trong production
- Nhược điểm:
    - Phụ thuộc vào nhà cung cấp dịch vụ
    - Ít kiểm soát hơn so với self‑hosted

## 7. Scalability & Performance

### 7.1 Memory

Mặc định, Qdrant tối ưu hiệu năng bằng cách lưu trữ vector trong RAM. Khi dữ liệu tăng lớn, Qdrant cho phép:

- Lưu vector hoặc index trên disk
- Sử dụng cơ chế cache để giữ các vector truy cập thường xuyên trong bộ nhớ

Cách tiếp cận này giúp cân bằng giữa chi phí phần cứng và hiệu năng truy vấn.

### 7.1 Sharding

Qdrant sử dụng **sharding** để chia collection thành nhiều phần nhỏ và phân phối chúng trên nhiều node khác nhau. Sharding cho phép:

- Mở rộng theo chiều ngang
- Phân tán tải truy vấn
- Tăng throughput của hệ thống

### 7.3 Replication

Replication giúp tạo nhiều bản sao của mỗi shard nhằm:

- Đảm bảo tính sẵn sàng cao
- Giảm nguy cơ mất dữ liệu
- Phân phối tải đọc trong các hệ thống có lượng truy vấn lớn

Trong môi trường production, replication factor lớn hơn 1 thường được khuyến nghị.

### 7.4 Segment config

Mỗi shard được chia thành các **segment**, là đơn vị lưu trữ và lập chỉ mục nhỏ hơn.

Cấu hình segment ảnh hưởng trực tiếp đến:

- Tốc độ ghi dữ liệu
- Hiệu năng truy vấn
- Thời gian tối ưu hóa index

Việc cân chỉnh số lượng và kích thước segment là một yếu tố quan trọng để đạt hiệu năng tối ưu.

## 8. Safety & Best Practices

### 8.1 Strict mode

Strict mode là cơ chế bảo vệ của Qdrant nhằm ngăn chặn các truy vấn hoặc thao tác có thể gây ảnh hưởng tiêu cực đến hiệu năng hệ thống. Strict mode có thể:

- Chặn lọc trên các trường payload chưa được lập chỉ mục
- Giới hạn kích thước truy vấn và batch insert
- Kiểm soát tần suất truy vấn

Cơ chế này đặc biệt hữu ích trong môi trường production nhiều người dùng.

### 8.2 Indexing strategy

Một số best practices khi làm việc với Qdrant:

- Xác định rõ các trường payload sẽ dùng để lọc và tạo payload index từ sớm
- Chọn distance metric phù hợp với loại embedding
- Tránh thay đổi cấu hình index khi hệ thống đang chịu tải cao
- Thiết kế schema collection phù hợp với use case ngay từ đầu

## 9. Conclusion

### 9.1 Khi nào nên dùng Qdrant

Qdrant phù hợp trong các kịch bản:

- Hệ thống cần **semantic search hoặc recommendation** ở quy mô lớn
- Pipeline **RAG** cho mô hình ngôn ngữ lớn
- Cần kết hợp **tìm kiếm ngữ nghĩa và lọc metadata** hiệu quả
- Yêu cầu độ trễ thấp và khả năng mở rộng cao

Qdrant không nhằm thay thế hoàn toàn cơ sở dữ liệu truyền thống, mà đóng vai trò **bổ sung** để xử lý lớp ngữ nghĩa của dữ liệu.

### 9.2 Khuyến nghị triển khai

Một kiến trúc điển hình là kết hợp:

- **Cơ sở dữ liệu truyền thống** (ví dụ: PostgreSQL) để quản lý dữ liệu nghiệp vụ và transaction
- **Qdrant** để xử lý vector search và semantic retrieval

Cách tiếp cận này giúp tận dụng thế mạnh của từng hệ thống và xây dựng các ứng dụng AI‑driven một cách hiệu quả và bền vững.